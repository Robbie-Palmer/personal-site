---
title: "Personal Site Architecture"
description: "A meta-examination of the technical decisions behind this self-documenting site: from Next.js and MDX to Cloudflare Pages and automated DevOps workflows"
date: "2025-11-02"
tags: ["web-development", "architecture", "devops", "meta"]
technologies: ["Next.js", "React", "TypeScript", "MDX", "Tailwind CSS", "Terraform", "Cloudflare Pages", "pnpm", "GitHub Actions"]
githubUrl: "https://github.com/Robbie-Palmer/personal-site"
demoUrl: "https://robbiepalmer.me"
---

## Overview

This personal site serves as both a portfolio and a living example of modern web architecture optimized for **AI-assisted development**. Every technology choice was made to maximize AI assistant effectiveness—not minimize complexity.

The site is built with **Next.js 15** using the App Router, deployed on **Cloudflare Pages**, and managed with **Terraform**. Development tooling includes **Mise** for environment management, **Husky** for git hooks, **Renovate** for dependency updates, and **AI-assisted code review**.

## The AI-Assisted Development Paradigm Shift

Traditional advice says "minimize complexity" and "choose the simplest tools." But in 2025, that paradigm is outdated.

**Old paradigm:**
- Minimize dependencies → reduce mental load
- Pick simple, vanilla tools → faster ramp-up
- Avoid abstractions → easier to understand

**New paradigm (AI era):**
- Choose **well-documented, popular tools** → AI writes better code
- Embrace **mainstream frameworks** → trained on more examples
- Build **proper abstractions** → easier for AI to extend

### Why This Matters

AI assistants like Claude Code are trained extensively on:
- Next.js (massive community, excellent docs)
- Terraform (ubiquitous infrastructure-as-code)
- Tailwind CSS (most popular utility CSS framework)
- TypeScript (industry standard for type safety)

When I use these tools, Claude generates **maintainable, idiomatic code** because it's seen thousands of similar examples. When I used niche tools or vanilla JavaScript in the past, AI assistants would produce inconsistent, buggy code based on limited training data.

### Architectural Escape Hatches

Another benefit: **extensibility for future needs**. Next.js provides:
- Server-side rendering if I need dynamic content later
- API routes for backend logic
- Middleware for authentication
- Edge functions for serverless compute

I'm not using these features *yet*, but the infrastructure supports them. With AI assistants handling the complexity, there's no penalty for choosing a framework with architectural escape hatches.

## Core Technology Decisions

### Why Next.js?

**Next.js 15** with the App Router provides the perfect balance of static site generation (SSG) and modern developer experience:

- **Static Site Generation (SSG)**: Blog posts and projects are pre-rendered at build time, resulting in near-instant page loads
- **React Server Components**: Reduces client-side JavaScript bundle size significantly
- **File-based routing**: Intuitive organization that maps directly to URLs
- **Built-in optimizations**: Image optimization, font optimization, and automatic code splitting
- **TypeScript-first**: Excellent type safety out of the box

Alternative considered: **Astro** would have been lighter, but I wanted to showcase my React expertise and leverage the broader React ecosystem.

### Why MDX?

**MDX** allows me to write content in Markdown while embedding React components when needed:

```mdx
# Regular Markdown

Here's a diagram:

<Mermaid chart={`
graph TD
    A[MDX] --> B[Markdown]
    A --> C[JSX Components]
`} />
```

This provides:
- **Content authoring in Markdown**: Fast writing without HTML
- **React component embedding**: Interactive demos, diagrams, custom layouts
- **Type-safe frontmatter**: Validated metadata using TypeScript interfaces
- **Syntax highlighting**: Using `rehype-pretty-code` with Shiki

### Content Architecture: Generic Content Management

Both blog posts and projects use a **generic content management system** that eliminates duplication while maintaining type safety:

```typescript
// lib/content.ts - Generic base for all content types
export class ContentManager<T extends BaseContent> {
  constructor(config: ContentConfig<T>) {
    // Shared file operations, validation, parsing
  }

  getAll(): T[]           // Read all items, sorted by date
  getBySlug(slug: string): T  // Get single item with security checks
  getAllSlugs(): string[]     // For static generation
}

// lib/blog.ts - Blog-specific configuration (53 lines)
interface BlogPost extends BaseContent {
  canonicalUrl?: string;
}

const blogManager = new ContentManager<BlogPost>({
  contentDir: "content/blog",
  validate: validateBlogPost,  // Type-safe frontmatter validation
});

// lib/projects.ts - Project-specific configuration (63 lines)
interface Project extends BaseContent {
  technologies?: string[];
  company?: string;
  role?: string;
  githubUrl?: string;
  demoUrl?: string;
  experienceLink?: string;
}

const projectManager = new ContentManager<Project>({
  contentDir: "content/projects",
  validate: validateProject,
});
```

**Why this architecture?**

This generic approach reduced code by **~600 lines** (75% reduction):
- `blog.ts`: 137 → 53 lines
- `projects.ts`: 185 → 63 lines
- `blog-list.tsx`: 218 → 45 lines
- `project-list.tsx`: 261 → 93 lines

More importantly, **adding new content types is now trivial**. Creating a "talks" or "notes" section requires ~10 lines:

```typescript
interface Talk extends BaseContent {
  venue?: string;
  slidesUrl?: string;
}

const talkManager = new ContentManager<Talk>({
  contentDir: "content/talks",
  validate: validateTalk,
});
```

When I add shared features like **commenting**, **plotting**, or **interactive diagrams**, they'll work across all content types immediately.

This demonstrates the AI-era principle: **proper abstractions make extensibility effortless**. Claude Code suggested and implemented this refactoring in minutes—something that would have taken hours of careful manual work.

### Why Static Site Generation?

SSG was the obvious choice for content that rarely changes:

- **Performance**: Pre-rendered HTML served from CDN edge locations
- **Cost**: Cloudflare Pages free tier is generous
- **Security**: No server to compromise, no database to breach
- **SEO**: Perfect for search engines (fully rendered HTML)
- **Scalability**: Handles traffic spikes effortlessly

The tradeoff is build time, but with incremental static regeneration patterns available in Next.js, this can be mitigated if needed.

## Infrastructure & DevOps

### Cloudflare Pages

**Cloudflare Pages** provides:
- **Global CDN**: Sub-100ms response times worldwide
- **Automatic deployments**: Every push to main triggers a build
- **Preview deployments**: Every PR gets its own URL
- **Custom domains**: Free SSL certificates
- **Edge functions**: Available if I need serverless compute

### Infrastructure as Code with Terraform

Managing Cloudflare configuration via **Terraform** ensures:
- **Reproducibility**: Infrastructure can be rebuilt from code
- **Version control**: Changes are tracked in Git
- **CI/CD integration**: Validated in pre-commit hooks and GitHub Actions
- **Documentation**: The code *is* the documentation

```hcl
resource "cloudflare_pages_project" "personal_site" {
  account_id        = var.cloudflare_account_id
  name              = "personal-site"
  production_branch = "main"

  build_config {
    build_command   = "pnpm run build"
    destination_dir = "ui/out"
  }
}
```

### Package Management: pnpm

**pnpm** over npm/yarn because:
- **Disk efficiency**: Shared dependency storage across projects
- **Strict dependency resolution**: Prevents phantom dependencies
- **Speed**: Faster installs than npm
- **Monorepo support**: Workspace features for ui/ and infra/

### Development Environment: Mise

**Mise** (formerly rtx) manages tool versions:

```toml
[tools]
node = "22"
pnpm = "9"
terraform = "1.10"
```

This ensures:
- Consistent environments across machines
- Automatic version switching per project
- Replaces multiple version managers (nvm, tfenv, etc.)

### Git Hooks with Husky

**Husky** enforces quality gates before commits:

- **Pre-commit**: Runs Biome formatter, type checking, linting
- **Pre-push**: Runs tests and Terraform validation
- **Commit-msg**: Validates conventional commit messages

This catches issues early, before CI/CD.

### Dependency Management: Renovate

**Renovate** automatically:
- Detects outdated dependencies
- Creates PRs with updates
- Groups related updates (e.g., all React packages)
- Runs tests before merging

This keeps the site secure and modern without manual effort.

## CI/CD Pipeline

### GitHub Actions Workflows

Three workflows handle different concerns:

**1. UI CI** (`ui-ci.yml`):
```yaml
- Lint code with Biome
- Type check with TypeScript
- Run tests with Vitest
- Build Next.js app
- Preview bundle size
```

**2. Infrastructure CI** (`infra-ci.yml`):
```yaml
- Validate Terraform syntax
- Format check Terraform files
- Run terraform plan
```

**3. Infrastructure CD** (`infra-cd.yml`):
```yaml
- Apply Terraform changes (main branch only)
- Deploy infrastructure updates
```

### AI-Assisted Development

**Claude Code** for implementation:
- Architecture discussions
- Code generation with context
- Refactoring assistance

**Code Rabbit** for PR reviews:
- Automated code review comments
- Suggests improvements
- Catches potential bugs

## Styling & Design System

### Tailwind CSS v4

**Tailwind CSS** provides:
- **Utility-first CSS**: Rapid UI development
- **Design consistency**: Predefined spacing, colors, typography
- **Purge unused styles**: Tiny production bundles
- **Dark mode**: Built-in theme support via `next-themes`

### shadcn/ui Components

**shadcn/ui** components are copied into the project (not imported as a library):
- Full customization control
- No bloated dependencies
- Accessible by default (Radix UI primitives)
- TypeScript-first

Components used:
- `Badge`, `Button`, `Card`, `Input`, `Separator`

### Typography Plugin

The `@tailwindcss/typography` plugin provides beautiful prose styling for MDX content without custom CSS:

```jsx
<div className="prose prose-zinc dark:prose-invert">
  <MDXRemote source={content} />
</div>
```

## Search & Discovery

### Fuzzy Search with Fuse.js

**Fuse.js** enables client-side fuzzy search across:

```typescript
keys: [
  { name: "title", weight: 3 },
  { name: "description", weight: 2 },
  { name: "tags", weight: 2 },
  { name: "content", weight: 1 },
]
```

**Why client-side?** With a small content set, client-side search:
- Eliminates server costs
- Provides instant results
- Works offline
- No privacy concerns (no search tracking)

### Tag-Based Filtering

Tags create taxonomy without complex categorization:
- Multiple tags per post/project
- Clickable tags filter content
- URL-based filtering (`?tag=architecture`)
- Shareable filtered views

## Performance Optimizations

### Bundle Size Management

- **Tree shaking**: Unused code eliminated
- **Code splitting**: Route-based chunks
- **Dynamic imports**: Heavy components loaded on demand

Example: Mermaid diagrams (heavy library) load only when needed:

```typescript
const Mermaid = dynamic(() => import('./mermaid'), {
  ssr: false,
  loading: () => <div>Loading diagram...</div>
});
```

### SEO & Metadata

Every page includes:
- **Open Graph tags**: Rich social previews
- **Twitter Cards**: Optimized sharing
- **Canonical URLs**: Prevents duplicate content penalties
- **Structured metadata**: Helps search engines understand content

## Testing Strategy

### Unit Testing with Vitest

**Vitest** over Jest because:
- **Faster**: Native ESM support, less configuration
- **Vite compatibility**: Shares config with build tool
- **Modern**: Better TypeScript support

**Testing Library** ensures tests focus on user behavior, not implementation details.

## What I'd Add Next

### Analytics (Privacy-Preserving)

Currently no analytics to respect privacy, but anonymous metrics would help understand:
- Which content resonates
- User navigation patterns
- Performance in the real world

**Plausible** or **Fathom** would be privacy-friendly options that don't track individuals.

### E2E Testing with Playwright

Playwright tests would catch:
- Navigation issues across browsers
- Mobile responsiveness problems
- Dark mode bugs
- Search/filter functionality

Currently relying on manual testing and type checking.

### Interactive Content Features

The generic content architecture makes it easy to add:
- **Commenting system** (maybe using GitHub Discussions API)
- **Interactive code playgrounds** (embedded sandboxes)
- **Data visualizations** (D3.js charts, plots)
- **Live demos** (embedded from CodeSandbox/StackBlitz)

Thanks to the abstracted content manager, these features would work across blog posts, projects, and any future content types.

## Lessons Learned

1. **Optimize for AI assistants, not just humans**: In 2025, choosing popular, well-documented frameworks (Next.js, Terraform, Tailwind) means AI assistants generate better, more maintainable code. The old advice to "minimize complexity" is outdated when AI handles the complexity for you.

2. **Abstractions enable rapid AI-assisted iteration**: The generic ContentManager refactoring took minutes with Claude Code, reduced code by 75%, and makes future extensions trivial. Proper abstractions aren't premature optimization—they're essential for AI-assisted development.

3. **Git worktrees + cloud dev environments scale with AI**: When AI can spin up entire features rapidly, the bottleneck becomes environment setup. Mise + containerized environments let me launch isolated workspaces in seconds.

4. **Infrastructure as Code is essential**: Even for simple deployments, Terraform provides reproducibility. AI assistants excel at Terraform because it's declarative and well-documented.

5. **Automation pays off exponentially**: Renovate, Husky, and GitHub Actions save hours of manual work. AI assistants can also maintain and improve these workflows automatically.

6. **Self-documenting projects create feedback loops**: Writing about the architecture *in* the project means the documentation is always up-to-date. Plus, Claude can read this file and understand the design decisions when making changes.

## Conclusion

This site represents a paradigm shift in how we think about web development architecture in the **age of AI assistants**. The traditional advice to "keep it simple" and "minimize complexity" no longer applies when AI handles that complexity for you.

Instead, the winning strategy is:
- **Choose popular, well-documented tools** → AI generates better code
- **Build proper abstractions** → AI extends them effortlessly
- **Optimize for extensibility** → architectural escape hatches are free
- **Embrace automation** → let AI maintain infrastructure

This site demonstrates these principles in action. The generic content architecture, comprehensive tooling, and infrastructure-as-code approach would have been "over-engineering" in 2020. In 2025, they're **essential for AI-assisted development velocity**.

The source code is available on [GitHub](https://github.com/Robbie-Palmer/personal-site), and the site itself is deployed at [robbiepalmer.me](https://robbiepalmer.me).

Future additions will showcase the benefits of this architecture:
- Interactive demos (leveraging the generic content system)
- Server-side features (using Next.js escape hatches)
- Complex visualizations (D3.js, Mermaid, plotting libraries)
- Integration with the Experience page

The infrastructure scales effortlessly from a personal blog to a full portfolio site with server-side rendering, authentication, and complex interactive features—all while maintaining AI-assistant-friendly code quality.
