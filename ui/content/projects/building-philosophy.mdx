---
title: "Building Philosophy"
description: "Engineering principles that guide architectural decisions and technology choices across all projects"
---

# Building Philosophy

## Short Feedback Loops

Shorten the path from idea to production.
People add process constantly - release managers, approval gates, "safety" mechanisms.
Decades of evidence says this kills velocity, increases the rate of incidents and leads to building the wrong thing.

Real users are the best test you'll ever have. Ship first.
Get to production to learn what actually matters. Then shift the burden left.
Actual problems teach more than any tutorial.

## Stack Rank, Don't Sprint

Story points are fiction. Sprint commitments are theater.

What works: a stack-ranked list at multiple levels of abstraction - tasks, epics, initiatives. Always know what's most important right now. Reprioritize constantly as you learn.

Planning should clarify priority, not predict the future.

## Build Flywheels

Build self-reinforcing systems - make small investments that compound.
Linear effort, exponential payoff.
Don't make flashy, one-off wins.
If the work doesn't compound, don't do it.
Flywheels should spin fast and stay light.

Feedback loops catch mistakes. Flywheels compound wins.

## The Goldilocks Zone

Pick technologies old enough to be reliable and well-documented, but not so old they're unsupported or talent-scarce.
Early adopters pay the cost of missing documentation, unpatched bugs, and shifting APIs.
Late adopters pay the cost of shrinking community and looming deprecation.
The window in between is where you want to be.

**Selection criteria:**

* **High floor, high ceiling** — Pick tools where it's hard to write bad code (high floor) but that scale to complex needs (high ceiling). Raise the baseline.
* **Shallow ramp** — Easy onboarding for yourself and collaborators. Quick to get started, deep when you need it.
* **Rising tides** — Build on platforms that are themselves growing and improving. Their momentum becomes yours.

When adopting new tech, do it deliberately and one at a time.
People often don't respect learning rate - the capacity of a team to absorb new domain knowledge,
tooling, and process at once.
Don't compound risk by going bleeding-edge on multiple fronts simultaneously.

## Split By Constraint, Not Dogma

Don't split services because "microservices are best practice." Split when you hit a real constraint - GPU workloads need different infrastructure than CPU. Different deployment targets need different artifacts. Different scaling characteristics need different resources.

Start as a monolith. Let actual constraints drive the architecture, not org charts or resume-driven development.

## Leverage Tech Debt

The optimal amount of tech debt is not zero. It is a tool, not a sin.
Strategic debt doesn't just make you faster - it makes things possible at all.

Friction is a resource allocation problem.
Where friction sits should reflect current priorities.
Not hiring? Optimizing onboarding is a waste.
Pre-product-market fit? Incomplete test coverage is fine - ship and learn.

But high friction in the path from idea to production is never acceptable.

## Less Is More

Every platform is overhead: another login, another UI, another bill, another integration point.
Consolidate where possible. Prefer tools that solve multiple problems over specialized single-purpose services.

Only build what makes you unique. Rent the rest.
If it's not your core business, buying is almost always cheaper than building and maintaining.

Fewer moving parts means more time shipping.

## LLM-Optimized

Every architectural decision needs to account for AI collaboration.
AI feeds on context. If it isn't in the repo, it doesn't exist.
Everything as code - content, infrastructure, database.

It also pushes towards general good practice for collaboration with team-mates, such as clear naming conventions
and predictable patterns. But now with stronger justification when trade-offs arise.

Boring tech is AI-readable tech. The model has seen `React` a billion times; it's hallucinating your bespoke framework.

## Documentation Rots

Writing documentation has immense value at the time.
It forces clarity of thinking, captures nuance that gets lost verbally, and synchronizes teams.

But that value has a short shelf life. Documentation is not connected to self-reinforcing feedback loops the way code is.
Code gets run by users, consumed by tests, validated constantly.
It gets continually rewritten and replaced as understanding of the product evolves.
But documentation just grows.
Trust the code, not the comment.

This site works through interconnected content and external readers who create a feedback loop.
ADRs work when the team actually references them during decisions.
READMEs work when new contributors use them to onboard.

Write for the moment. Don't expect it to last.

## Build in Public

Building in private has costs people rarely account for.
Security, access control, tooling to manage it all - energy not going into the product.

Public repositories are also just cheaper. GitHub Actions runs free. CodeRabbit reviews are free.

Showing mistakes matters as much as showing wins.
Fast feedback and incremental shipping mean things will be imperfect in public.
That's fine - visibility forces focus on what is truly important.

## Generalists Over Specialists

Specialists become bottlenecks. They create queues, handoffs, and artificial boundaries.

T-shaped engineers - broad knowledge, deep in one or two areas - move faster and see the whole picture.
They can unblock themselves. They don't wait for "the database person" or "the frontend person."

## Goodhart's and Conway's Laws

Goodhart's Law: when a measure becomes a target, it ceases to be a good measure.
Measure things, but don't make them targets.

Conway's Law: systems mirror the communication structures of the organizations that build them.
Structure your teams to get the architecture you want.
