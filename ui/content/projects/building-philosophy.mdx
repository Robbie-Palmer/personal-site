---
title: "Building Philosophy"
description: "Engineering principles that guide architectural decisions and technology choices across all projects"
---

# Building Philosophy

These principles guide how I approach all my projects—from architecture decisions to technology choices to development practices. They represent hard-won lessons and deliberate trade-offs that optimize for shipping quality software sustainably.

## Ship Incrementally

Continuous delivery over big-bang releases. Every PR should be deployable. Small, frequent changes reduce risk and maintain momentum.

Working software beats comprehensive planning. Ship the smallest valuable increment, gather feedback, iterate. Long-running feature branches accumulate merge conflicts and delay value delivery. Deploy often, behind feature flags if needed.

## Lean & Agile

Build only what's needed. Validate assumptions early. Inspired by Extreme Programming and lean principles—working software over comprehensive documentation, but documentation where it adds value.

Avoid speculative features. Don't build for hypothetical future requirements. YAGNI (You Aren't Gonna Need It) saves time and complexity. When requirements change—and they will—simpler code is easier to modify.

## Choose Boring Technologies

Leverage mature ecosystems, strong communities, and deep LLM knowledge bases. Innovate where it matters—where my unique perspective adds value—not on the bleeding edge across multiple fronts simultaneously. The innovation is in the confluence: the whole greater than the sum of its parts.

Use battle-tested tools with known failure modes. Bleeding-edge tech brings excitement but also undocumented edge cases, breaking changes, and sparse Stack Overflow answers. Boring technologies let you focus on solving domain problems instead of fighting your tools.

When adopting new tech, do it deliberately and one at a time. Don't compound risk by going bleeding-edge on multiple fronts simultaneously.

## Minimize Platforms, Maximize Velocity

Reduce context-switching and administrative overhead. Fewer tools, fewer accounts, fewer things to maintain means more time shipping. This site consolidates what would otherwise be scattered across multiple services.

Every additional platform has a cost: another login to remember, another UI to learn, another bill to pay, another integration to maintain. Centralize where possible. Use monorepos over polyrepos. Prefer platforms that solve multiple problems (GitHub for code, CI/CD, and project management) over specialized single-purpose tools.

## LLM-Optimized

The codebase is structured for AI pair programming: clear naming conventions, documented decisions, predictable patterns. This isn't just about using AI tools—it's about writing code that's readable by any intelligence, human or otherwise.

Code optimized for LLMs is also optimized for human collaboration: clear file structure, consistent patterns, well-named functions, documented architectural decisions. AI coding assistants are most effective with popular frameworks (more training data), clear abstractions (easier to reason about), and comprehensive tests (catch hallucinations).

## Documentation as Product

ADRs, PRDs, and inline documentation aren't overhead—they're deliverables. They capture thinking, enable collaboration, and reduce the cost of returning to a project after time away.

Write documentation for your future self. In six months, you won't remember why you chose PostgreSQL over MongoDB, or why you structured state management this way. ADRs capture context and rationale. Good docs enable you to context-switch efficiently and onboard collaborators (human or AI) quickly.

Documentation doesn't mean comprehensive comments on every line. It means:
- ADRs for significant architectural decisions
- README files that explain how to run the project
- Inline comments for non-obvious logic (not what the code does, but why)
- Type signatures and tests as executable documentation

## Build in Public

Ideas gain value through collaboration. Writing publicly forces rigor and invites feedback. The goal isn't to hoard knowledge but to share it in a way that's useful to others.

Public building creates accountability. It's harder to cut corners when your work is visible. Sharing knowledge early—even incomplete ideas—invites feedback and refinement. The best ideas improve through iteration and collaboration.

Open source isn't just about code—it's about sharing thinking. Blog posts explaining decisions, ADRs documenting trade-offs, and public repos demonstrating implementations all contribute to the collective knowledge base.

---

These principles aren't dogma—they're heuristics. Every project brings unique constraints. But when in doubt, default to these patterns. They optimize for sustainable velocity, quality outcomes, and maintainable systems.
